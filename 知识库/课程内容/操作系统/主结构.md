## 1.1 操作系统的目标和作用

### 1.1.1 操作系统的目标
在计算机上配置OS，主要目标是实现：方便性、有效性、可扩充性、开放性

**方便性**

未配置OS的计算机系统只能用机器语言编程，而配置了OS的计算机系统可以使用编译命令将高级语言编写的程序翻译成机器代码。

**有效性**

第一层含义是提高系统资源的利用率，第二层含义是提高系统的吞吐量。OS可以通过合理的组织计算机的工作流程，加速程序的运行，缩短程序的运行周期来提高系统的吞吐量。

**可扩充性**

OS从早期的无结构发展成模块化结构，进而发展成分层式结构，近年OS广泛采用微内核结构。该结构方便增添新的功能和模块，对原有功能和模块进行修改，具有良好的扩充性。

**开放性**

开放性是系统能遵守国际标准，特别是遵循开放系统互连（OSI）参考模型，凡遵守国际标准开发的硬件和软件都能彼此兼容。

### 1.1.2 操作系统的作用

**OS作为用户与计算机硬件系统之间的接口**

用户可以通过3中方式来使用计算机，即通过命令方式、系统调用方式和图形/窗口方式来实现与OS的通信，并取得OS的服务。

**OS作为计算机系统资源的管理者**

计算机系统中资源分为4类：处理机、存储器、I/O设备以及信息（数据与程序）。

当一台计算机系统同时供多个用户使用，可能对系统中共享资源的需求可能会有冲突，为此OS必须对共享资源的使用请求进行授权来进行协调。

**OS实现了对计算机资源的抽象**

为了方便用户使用I/O设备，在裸机上覆盖了一层I/O设备管理软件，隐藏了I/O设备操作的细节，通常把覆盖了上述软件的I/O设备称为扩充机器或虚机器，他向用户提供了一个可以对硬件进行操作的抽象模型而无需了解物理接口的实现细节。

同理为了方便用户使用文件系统，又可在第一层软件（I/O软件）之上覆盖了一层用于管理文件的软件，用于实现对文件操作的细节。

OS是铺设在计算机硬件上多层软件的集合，增强了对硬件操作的功能，隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。

### 1.1.3 推动操作系统发展的主要动力

**不断提高计算机系统资源的利用率**

20世纪50年代计算机系统特别昂贵，提高系统资源利用率成为最初的推动力，由此促成了单道批处理系统到多道批处理系统的演变，通过减少计算机的空闲时间提高了CPU和I/O的利用率。

20世纪60年代，又出现了可支持多个用户使用一台计算机的分时系统，使系统资源利用率提高，推动了计算机第一次大普及。与此同时，推出了能改善I/O设备和CPU利用率的假脱机系统。

20世纪70年代，提出了逻辑上扩大内存的虚拟存储器技术。之后网络环境下，在服务器上共享资源给全网用户，进一步提高了利用率。

**方便用户**

用户使用计算机和调试程序时不方便称为主要矛盾，称为推动OS发展的主要因素。20世纪60年代分时系统出现，不仅提高了资源利用率，还能实现人机交互。

20世纪90年代，图形用户界面的出现方便了用户对计算机的使用，推动了计算机的普及和广泛应用。

**器件不断更新换代**

随着信息技术的发展，尤其是微机芯片的不断更新换代，计算机性能提高，OS功能和性能也迅速提高。比如微机芯片从8位发展到16位、32位、64位，相应的OS出现了16位、32位、64位。

同时外部设备不断发展，OS支持的设备越来越多，比如光盘、移动硬盘、闪存、扫描仪、数码相机等。

**计算机体系结构不断发展**

计算机体系结构推动OS的发展，如计算机从单处理机系统发展成多处理机系统时，相应的OS从单处理机发展为多处理机OS；出现了计算机网络后，配置在计算机网络上的网络OS应运而生。

**不断提出新的应用需求**

例如，为了提高产品的质量和数量，需将计算机应用于工业控制中，此时在计算机上需要配置能进行实时控制的OS，由此产生了实时系统。

为了能满足用户在计算机播放视频，从网上下载视频等需求，在OS中添加了多媒体功能。

随着超大规模集成电路VLSI的发展，CPU体积越来越小，价格越来越便宜，大量智能设备（如智能手机）应运而生，嵌入式OS应运而生。


## 1.2 操作系统的发展过程

20世纪50年代中期，出现了第一个批处理系统；20世纪60年代中期，出现了多道批处理系统，不久又推出了分时系统，用于工业控制和武器控制的实时系统也问世。20世纪70-90年代，VLSI和计算机体系结构大发展的时代，微OS、多处理机OS、网络OS和分布式OS都得到了发展。

### 1.2.1 未配置操作系统的计算机系统

## 1.3 操作系统的基本特征

### 1.3.1 并发

系统中的程序能并发执行，才能有效地提高系统中资源的利用率。

> 并行与并发：
>
> 并行指两个或多个事件在同一时刻发生，并发是两个或多个事件在同一时间间隔内发生。
>
> 在多道程序环境下，并发是指在一段时间内宏观上多个程序在同时运行；在单处理机系统中，每一时刻仅能有一道程序执行，在微观上这些程序只能分时交替运行。也就是说宏观上4道程序同时运行，但微观上4个程序分时交替执行。
>
> 如果计算机系统有多个处理机，多个任务可分到多个处理机并发执行。

进程：

进程是指在系统中能独立运行并作为资源分配对象的基本单位，由一组指令、数据、堆栈构成，是一个能独立运行的活动实体。

未引入进程的系统中，同属于一个应用程序的计算程序和I/O程序只能顺序执行，但分别为他们建立一个进程后，两个进程便可并发执行。

### 1.3.2 共享

### 1.3.3 虚拟

早期物理信道只能供一对用户使用，虚拟技术通过空分复用或时空复用，变成供多对用户通话的逻辑信道。

**时空复用技术**

虚拟处理机技术：利用多道程序设计技术，为每道程序建立至少一个进程

## 1.6 操作系统的结构

早期OS的规模很小，如只有几十KB，完全可以由一个人用几个月的时间编制出来。此时，编制程序基本上是一种技巧，OS是否有结构并不那么重要。但随着OS规模的愈来愈大，其所具有的代码也愈来愈多，往往需要由数十人、数百人甚至更多的人参与，通过分工合作来共同完成其设计。这意味着，应采用工程化的开发方法来对大型软件进行开发，由此产生了“软件工程学”。

软件质量可用这样几个指标来评价：功能性、有效性、可靠性、易用性、易维护性和易移植性。为此，先后产生了多种OS开发方法，如模块化方法、结构化方法和面向对象的方法等。利用不同的开发方法，所开发出的OS将具有不同的结构。

### 1.6.1 简单结构

在早期开发OS时，设计者只把他的注意力放在了功能的实现和获得更高的效率上，而缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程均可任意地调用其他过程，这致使OS内部既复杂、又混乱。因此，这种OS是无结构的，也有人把它称为整体系统结构或简单结构。

此时，程序设计的技巧仅在于如何编写紧凑的程序，以便于有效地利用内存。当系统不太大时，在一个人能够完全理解和掌握的情况下，设计出的OS所存在的问题还不是太大：但随着系统的不断扩大，所设计出的OS就会变得既庞大、又杂乱。这一方面会使所综写的程序错误很多，给调试工作带来很多困难；另一方面会使程序难以阅读和理解，增加了维护人员的负担。

简单结构OS的一个典型例子是MS-DOS系统。该系统并没有很好地区分功能的接口和层次。例如，应用程序能访问基本的I/O程序，并能将数据直接写到显示器和磁盘。这种自由度使MS-DOS系统易受错误（或恶意）程序的伤害，进而可能会导致整个系统崩溃。当然，MS-DOS系统还受限于当时的硬件，其所用的intel 8088微处理机未能提供双模式和硬件保护功能，因此，设计人员除了允许应用程序访问基础硬件外，没有其他选择。

### 1.6.2 模块化结构

**1、模块化程序设计技术的基本概念**

模块化程序设计技术，是20世纪60年代出现的一种结构化程序设计技术。该技术基于“分解”和“模块化”原则来控制大型软件的复杂度。为使OS具有较清晰的结构，不再将众多的过程直接构成OS，而是将OS按其功能精细地划分为若干个具有一定独立性和大小的模块。每个模块具有某方而的管理功能，如进程管理、存储器管理、文件管理等，并仔细地规定好各模块间的接口，使各模块之间能通过该接口实现交互。然后进一步将各模块细分为若干个具有一定功能的子模块，如把进程管理模块分为进程控制、进程调度等子模块，各子模块之间的接口同样也要规定好。若子模块较大，则可将其再进一步细分。我们把这种设计方法称为模块接口法，由此构成的的OS就是具有模块化。图1.9所示为由模块、子模块等构成的具有模块化结构的OS。

![image-20220924091334037](https://pic.imgdb.cn/item/632e5a1616f2c2beb1703b6b.png)

**2、模块独立性**

在采用模块一接口法设计OS结构时，关键问题是模块的划分和规定好模块之间的接口。如果在划分模块时将模块划分得太小，则虽然可以降低模块本身的复杂性，但也会导致模块之间的联系过多，进而导致系统比较混乱；如果将模块划分得过大，则又会增加模块内部的复杂性。因此在划分模块时，应在“两者”之间进行权衡。

另外，在划分模块时，必须充分注意模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性有以下两个标准：①内聚性，指模块内部各部分间联系的紧密程度，内聚性越高，模块独立性越强：②耦合度，指模块间相互联系和相互影响的程度，显然，桐合度越低，模块独立性越强。

**3、模块一接口法的优缺点**

利用模块-接口法开发的OS,较无结构0S具有以下显著优点：①提高了OS设计的正确性、可理解性和易维护性；②增强了OS的可适应性：③加速了OS的开发过程

模块化结构设计仍存在下述问题：①在设计OS时，对各模块间接口的规定，很难满足划分完成后模块对接口的实际需求；②在OS设计阶段，设计者必须做出一系列的决定（决策)，每个决定必须建立在上一个决定的基础上，但在模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，进而造成了各种决定的“无序性”，这将使程序员很难做到“设计中的每一步决定”都是建立在可靠的基础上的，因此模块-接口法又被称为“无序模块法”。

目前，设计OS的常用方法是采用可加载的内核模块(loadable kernel module)。这里，内核有一组核心组件，无论在启动时还是在运行时，内核都可以通过模块链入额外服务。这种类型的设计常见于现代UNIX系统（如Solaris、Linux:或Mac OS X等）以及Windows系统的实现过程中。这种设计的思想是：内核提供核心服务，而其他服务可在内核运行时动态实现。动态链接服务优于直接添加新功能到内核，这是因为对于每次更改，后者都需要重新编译内核。

### 1.6.3 分层式结构

**1、分层式结构的基本概念**

为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法。有序分层法的设计任务是，在目标系统A和裸机系统（又称宿主系统）A之间，铺设若干个层次的软件A,A2,,A1,使A通过A,Ar,A2,A,层软件，最终能在A上运行。在OS中，常采用自底向上分层设计法来铺设这些中间层软件。

自底向上分层设计法的基本原则是：每一步设计都是建立在可靠的基础上的。为此规定，每一层仅能使用其低层所提供的功能和服务，这样可使系统的调试和验证都变得更容易。例如，在调试第一层软件A,时，由于它使用的是一个完全确定的物理机器（宿主系统）所提供的功能，在对A,层软件经过精心设计和几乎是穷尽无遗的测试后，可以认为A,是正确的，而且它与其所有的高层软件A,A,,A,无关；同样在调试第二层软件A,时，它也只使用了A,层软件和物理机器所提供的功能，而与其高层软件A,A,…,A,无关，如此一层一层地自底向上增添软件层，每层都实现若干功能，最后总能构成一个可以满足用户需婴的OS。在用这种方法构成OS时，已将一个OS分为若干个层次，每层又由若干个模块组成，各层之间只存在单向的依赖关系，即高层仅依赖于紧邻它的低层。

**2、分层式结构的优缺点**

分层式结构的主要优点有：①易保证系统的正确性，自下而上的设计方式，使所有设计中的决定都是有序的，或者说是建立在较为可靠基础上的，这样比较容易保证整个系统的正确性；②可保证系统的易维护性和可扩充性，若想在系统中增加、修改或替换一个层次中的模块或整个层次，则只要不改变相应层次间的接口，就不会影响其他层次，这必将使系统维护和打充变得更加容易。

分层式结构的主要缺点是系统效率较低。由于分层式结构是分层单向依赖的，必须在各层之间都建立层问的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率降低。

### 1.6.4 微内核结构

OS的微内核(microkernel)结构，是20世纪80年代后明发袋起米的。由于上形有双世义多处理机运行，故非常适用于分布式系统环境。当前比较流行的、能支持多处理机运行的OS,几乎全部都采用了微内核结构，例如卡内基梅隆大学研制的Mach OS,便属于微内核结构的OS:再如Vindows2000/XP系统，也采用了微内核结构。

**1、微内核OS的基本概念**

为了提高OS的“正确性”“灵活性”“易维护性”和”可扩充性”，在进行现代OS结构设计时，即使在单处理机环境下，也大都会采用基于客户/服务器模式的微内核结构，将OS划分为两大部分：微内核和多个服务器。至于什么是微内核结构，现在尚无公认的定义，但可以从以下4个方面对微内核结构的OS进行描述。

- 足够小的内核。

在微内核结构的OS中，内核是指精心设计的、能实现现代OS最基本核心功能的小型内核，微内核并不是一个完整的OS,而只是OS中最基本的部分，它通常包含：①用于处理与硬件紧密相关的部分；②一些最基本的功能；③客户和服务器之间的通信。它们只是为构建通用0S提供了一个重要基础。这样就可以确保把OS内核做得很小。

- 基于客户/服务器模式。

由于客户/服务器模式具有非常多的优点，故在单处理机微内核结构的OS中几乎无一例外地都采用了客户/服务器模式，将OS中最基本的部分放入内核中，而把OS的绝大部分功能都放在微内核外面的一组服务器（进程）中实现，例如，用于提供进程（线程）管理功能的进程（线程)服务器、提供虚拟存储器管理功能的虚拟存储器服务器、提供/O设备管理功能的/O设备服务器等，都是被作为进程来实现的，它们运行在用户态。客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。图1-10所示为单处理机环境下的客户服务器模式。

![image-20220924092955509](https://pic.imgdb.cn/item/632e5dec16f2c2beb1745011.png)

- 采用策略与机制分离原则

在现代OS的结构设计中，经常会采用策略与机制分离原则来构造OS结构。所谓机制，是指实现某一功能的具体执行机构：而策略，则是指在机制的基础上，借助于某些参数和算法来实现该功能的优化或达到不同的功能目标。通常，机制处于系统的基层，而策略则处于系统的高层。在传统OS中，将机制放在OS内核的较低层，将策略放在OS内核的较高层。而在微内核OS中，通常将机制放在OS的微内核中。正因为如此.才有可能将内核做得很小。

- 采用面向对象技术

OS是一个极其复杂的大型软件系统，我们不仅可以通过结构设计来降低OS的复杂度，还可以基于面向对象技术中的“抽象”和“隐蔽”原则控制系统的复杂性，再进一步利用“对象”“封装”“继承”等概念来确保0S的“正确性”“可靠性”“易修改性”“易扩展性”等，并提高OS的设计速度。正因面向对象技术能带来如此多的好处，所以面向对象技术被广泛应用于现代OS的设计中。



**2、微内核的基本功能**

微内核应具有哪些功能，或者说哪些功能应放在微内核中，哪些功能应放在微内核外，目前尚无明确的规定。现在通常采用策略与机制分离原则，将机制部分以及与硬件紧密相关的部分放人微内核中。由此可知，微内核通常具有以下几个方面的功能。

- 进程（线程）管理

大多数的微内核OS,对于进程管理功能的实现，都采用策略与机制分离原则。例如，为实现进程（线程）调度功能，须在进程管理中设置一个或多个进程（线程）优先级队列，以将指定优先级进程（线程）从所在队列中取出，并将其投入执行。由于这一部分属于调度功能的机制部分，故应将它放入微内核中。如何确定各类用户（进程）的优先级，又应如何确定每类用户中各用户的优先级等问题，都属于策略问题，可将它们放入微内核外的进程（线程）管理服务器中，以完成上述“确定”任务。由于进程（线程）之间的通信功能是微内核OS最基本的功能，会被频繁使用，因此几乎所有的微内核0S都将进程（线程）之间的通信功能放人微内核中。此外，还将进程的切换、线程的调度以及多处理机之间的同步等功能也放人微内核中。

- 低级存储器管理

通常在微内核中，只配置最基本的低级存储器管理机制，例如，用于实现将用户空间的逻辑地址变换为内存空间的物理地址的页表机制和地址变换机制，这一部分是依赖于机器的，因此放入微内核中。而实现虚拟存储器管理的策略，包含应采用何种页面置换算法、采用何种内存分配与回收策略等，则应放在微内核外的存储器管理服务器中。

- 中断和陷入处理

大多数微内核OS都将与硬件紧密相关的一小部分放入微内核中进行处理，此时微内核的主要功能是捕获所发生的中断和陷人事件，并进行相应的前期处理，如进行中断现场保护、识别中断或陷入事件的类型等，然后将有关事件的信息转换成消息，并把它发送给相关的服务器：由服务器根据中断或陷入事件的类型，调用相应的处理程序来进行后期处理。在微内核0S中，将进程管理、存储器管理、0管理等功能一分为二，并将其中属于机制的、很小的一部分放入微内核中，另外的绝大部分放在微内核外的各种服务器中。事实上，微内核外的大多数服务器都要比微内核大。这进一步说明了为什么能在采用客户/服务器模式后，还能把微内核做得很小的原因。



**3、微内核OS的优点**

由于微内核结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术，因此，微内核结构的OS是集各种技术优点之大成。现将其优点细述如下。

- 提高了系统可扩展性

由于微内核OS的许多功能是由相对独立的服务器软件来实现的，当开发了新的硬件和软件时，微内核OS只须在相应的服务器中增加新的功能，或再增加一个专门的服务器即可。与此同时，微内核结构也必然会改善系统的灵活性，因为不仅可在0S中增加新的功能，还可修改原有功能，以及删除已过时的老功能，进而形成一个更为精干的、有效的OS。

- 增强了系统的可常性。

一方面，微内核是经过精心设计和严格测试的，这容易保证其正确性；另一方面，微内核提供了规范而精简的应用程序接口(application programming interface,API),这为在微内核外部编写高质量的程序创造了条件。此外，由于所有服务器都运行在用户态，服务器与服务器之间采用的是消息传递通信机制，因此，某个服务器出现错误不会影响微内核，也不会影响其他服务器。

- 增强了系统的可移植性

随着硬件的快速发展，出现了各种各样的硬件平台，作为一个好的OS,必须具备可移植性，以使自身能够较容易地运行在不同的计算机硬件平台上。在微内核结构的OS中，所有与特定CPU和/O设备有关的代码，均放在微内核和微内核下面的硬件隐藏层中，而OS的其他绝大部分组件（各种服务器）均与硬件平台无关，因而，把0S从一个计算机硬件平台移植到另一个计算机硬件平台上所须做的修改是比较小的。

- 提供了对分布式系统的支持

在微内核OS中，由于客户和服务器之间、服务器和服务器之间的通信，均采用消息传递通信机制实现，微内核OS能很好地支持分布式系统和网络系统。事实上，只要在分布式系统中赋予所有进程和服务器唯一的标识符，在微内核中再配置一张系统映射表（即进程和服务器的标识符与它们所驻留的机器之间的对应表)，在进行客户与服务器通信时，只须在所发送的消息中标上发送进程和接收进程的标识符，微内核便可利用系统映射表将消息发往“目标”，而无论“目标”驻留在哪台机器上。

- 融入了而向对象技术

在设计微内核OS时，采用了面向对象技术，其中的“封装”“继承”“对象类”和“多态性”，以及在对象之间采用消息传递机制等，都十分有利于提高系统的“正确性”“可靠性”“易修改性”“易扩展性”等，而且还能显著减少开发系统的开销。



**4、微内核OS存在的问题**

应当指出，在微内核OS中，由于采用了非常小的内核，客户服务器模式和消息传递机制，虽给微内核OS带来了许多优点，但也使微内核OS存在着缺点，其中最主要的缺点是相比于早期的OS,微内核OS的运行效率有所降低。效率降低最主要的原因是，在完成一次客户对OS提出的服务请求时，需要利用消息实现多次交互，以及进行用户内核模式和上下文的多次切换。然而，在早期的OS中，用户进程在请求取得OS服务时，一般只须进行两次上下文的切换：一次是在执行系统调用后，由用户态转向内核态时：另一次是在系统完成用户请求的服务后，由内核态返回用户态时。

在微内核OS中，客户和服务器、服务器和服务器之间的通信都须通过微内核，这使得同样的服务请求至少需要进行4次上下文切换。第1次发生在客户发送请求消息给微内核，以请求取得某服务器特定的服务时；第2次发生在由微内核把客户的请求消息发往服务器时；第3次发生在服务器完成客户的请求后，把响应消息发送到微内核时：第4次发生在微内核将响应消息发送给客户时。实际情况往往还会引起更多的上下文切换。例如，当某个服务器自身尚无能力完成客户请求而需要其他服务器帮助时，如图1-1所示，其中的文件服务器需要磁盘设备服务器的帮助，这时就需要进行8次上下文的切换。

![image-20220924094227115](https://pic.imgdb.cn/item/632e61ab16f2c2beb1783689.png)

为了改善运行效率，可以重新把OS的一些常用基本功能，由服务器移入微内核中。这样可使客户对OS常用基本功能的请求所引发的用户/内核模式和上下文的切换次数，由4次或8次降为2次。但这又会使微内核的容量明显增大，使其在小型接口定义和适应性方面的优势有所下降，同时会提高微内核的设计代价。

### 1.6.5 外核结构

在传统OS中，只有内核可以管理硬件资源，应用程序通过内核提供的抽象接口间接地与硬件进行交互。随着计算机产业的逐步发展，应用程序的需求多样性开始增加，内核提供的接口因具有固定性而成为应用程序提升性能、增强灵活性和拓展功能的瓶颈。但是，应用程序的需求一直在发生变化，这使得OS为每个应用程序的每种需求都提供一个接口并不现实。因此，传统OS难以适应应用程序的个性化需求。

外核(exoker©l)或外内核OS的基本思想是：内核不提供传统OS中的进程、虚拟存储器等抽象事物，而是专注于物理资源的隔离（保护）与复用。具体来说，在基于外核结构的0S中，一个非常小的内核负责保护系统资源，而硬件资源的管理职责则委托给应用程序。这样，OS就可以做到在保证资源安全的前提下，减少对应用程序的限制，充分满足应用程序对硬件资源的不同需求。图1-12所示为美国麻省理工学院实现的具有外核结构的A©gis系统，这个系统由一个轻量级内核和库0S组成。外核只提供比较低层的硬件操作，在外核接口上层工作的库OS则侧提供更高级别的映射。这里的库OS的实现思想是：基于应用程序的需求来定制OS内核，将原本属于OS内核的功能以库的形式提供给用户。

![image-20220924094327662](https://pic.imgdb.cn/item/632e619e16f2c2beb1782837.png)

## 1.7 系统调用

程序接口是OS专门为用户程序而设置的，提供给程序员编程时使用，也是用户程序取得OS服务的唯一途径。程序接口由一组系统调用(system call)组成，因此，系统调用提供了用户程序和OS内核之间的接口。系统调用不仅可供所有的应用程序使用，还可供OS自身使用。在每个系统中，通常有几十条甚至上百条系统调用，可根据功能将它们划分成若干类，每一个系统调用都是一个能完成特定功能的子程序。

### 1.7.1 系统调用的概念

在OS中提供系统调用的目的是，使应用程序可以通过系统调用来间接调用OS中的相关过程，进而取得相应的服务。系统调用在本质上是应用程序请求OS内核完成某功能时的一种过程调用，但它是一种特殊的过程调用，它与一般的过程调用在下述几方面有着显著差别。

- 运行在不同的系统状态。一般的过程调用，其调用程序和被调用程序运行在相同的状态一内核态或用户态；而系统调用与一般的过程调用的最大区别就在于，系统调用的调用程序运行在用户态，而被调用程序运行在内核态。
- 状态的转换。由于一般的过程调用并不涉及系统状态的转换，因此可直接由调用过程转向被调用过程。但在运行系统调用时，由于调用过程和被调用过程工作处于不同的系统状态，因而不允许由调用过程直接转向被调用过程，需要通过软中断机制先由用户态转换为内核态，经内核分析后才能转向相应的系统调用处理子程序。
- 返回问题。在采用了抢占式（剥夺）调度方式的系统中，在被调用过程执行完成后，要对系统中所有要求运行的进程做优先级分析。当调用进程仍具有最高优先级时，才返回到调用进程继续执行；否则，将重新调度，以便让优先级最高的进程优先执行。此时，将把调用进程放入就绪队列。
- 嵌套调用。像一般的过程调用一样，系统调用也可以嵌套进行，即在一个被调用过程执行期间，还可以利用系统调用命令去调用另一个系统调用。当然，每个系统调用对嵌套调用的深度都有一定的限制，如最大深度为6。但一般的过程调用对嵌套调用的深度则没有限制。图1-13所示为无嵌套调用与有嵌套调用这两种情况下的系统调用。

![image-20220924084733371](https://pic.imgdb.cn/item/632e540316f2c2beb16a3e76.png)

要写一个程序，从一个文件中读出数据，再将该数据复制到另一文件中。首先须输人该程序的输入文件名和输出文件名。文件名由程序来询问这两个文件名。在交互式系统中，该方式要使用一系列的系统调用，先在屏幕上打印出一系列的提示信息，再从键盘终端读人定义这两个文件名的字符串。在获得两个文件名后，程序又必须利用系统调用open去打开输人文件，并用系统调用creat去创建指定的输出文件；在执行系统调用open时，又可能发生错误。

例如，程序试图去打开一个不存在的文件，或者该文件虽然存在，但并不允许被访问等。此时，程序又须利用多条系统调用去显示出错信息，继而利用一个系统调用去实现程序的异常终止。类似地，在执行系统调用creat时，同样可能出现错误。例如，系统中早已有了与输出文件同名的另一文件，这时又须利用一个系统调用来结束程序，或者利用一个系统调用来删除已存在的那个同名文件，此后再利用系统调用creat来创建输出文件。

在打开输入文件和创建输出文件都获得成功后，还须通过用于申请内存的系统调用alloc来根据文件的大小申请一个缓冲区。申请成功后，再利用系统调用read从输入文件中把数据读到缓冲区内。读完后，又用系统调用close去关闭输人文件。然后，利用系统调用write把缓冲区内的数据写到输出文件中。在读过程或写过程中，都有可能需要回送各种出错信息。例如，在写过程中，可能发现已到达文件末尾指定的字符数尚未读够，或者遇见各种与输出设备类型有关的错误（如已无磁盘空间、打印机缺纸等）：在读过程中，可能发现硬件故障，如奇偶校验错误等。在将整个文件复制完后，程序又须利用系统调用close去关闭输出文件，并向控制台发出一消息，以指示复制完毕。最后，再利用系统调用exit使程序正常结束。综上所述可知，一个用户程序需要频繁地利用各种系统调用来取得OS所提供的多种服务。

系统调用是通过中断机制实现的，并且一个OS的所有系统调用都通过同一个中断入口来实现。例如，MS-DOS系统提供了INT21H这一中断，应用程序通过该中断获取OS的服务。对于拥有保护机制的OS来说，中断机制本身也是受保护的。在IBM公司所生产的个人计算机上，1ntel提供了多达255个中断号，但只有授权给应用程序保护等级的中断号，才可以被应用程序调用的。对于未被授权的中断号，如果应用程序对其进行调用，则会引发保护异常，进而导致自己被OS停止。例如，Linux系统仅给应用程序授权了4个中断号，即3H、4H、5H、80H，前3个中断号是提供给应用程序进行调试所使用的，而80H则是用于系统调用的中断号。

### 1.7.2 系统调用的类型

**1、进程控制类系统调用**

- 创建和终止进程的系统调用。利用创建进程的系调用为想要参加并发执行的程序创建一个进程，当进程执行结束后，再利用终止进程的系统。用来终止该进程。
- 获得和设置进程属性的系统调用。进程的属性包括进程标识符、进程代先级、最大允许执行时间等。利用获得进程属性的系统调用可了解某进程的属性，利用设置透属性的系统调用可确定和重新设置进程的属性。
- 等待某事件出现的系统调用。进程在执行过程中，假设需要等待某事件（条件）出现后方可继续执行。此时，进程可利用等待某事件出的系统调用来使自己处于等待状态，一旦等待的事件出现，便可将自己唤醒。

**2、文件操纵类系统调用**

- 创建和删除文件的系统调用。利用创建文件的系统调用，请求系统创建一个新文件；利用删除文件的系统调用，将指定文件删除。
- 打开和关闭文件的系统调用。用户在第一次访问某个文件之前，应先利用打开文件的系统调用将指定文件打开；在访问结束后，应利用关闭文件的系统调用将指定文件关闭。
- 读和写文件的系统调用。用户可利用读文件的系统调用，从已打开的文件中读出给定数目的字符，并将它们送至指定的缓冲区中；也可利用写文件的系统调用，从指定的缓冲区中将给定数目的字符写入文件中。读和写文件的系统调用是文件操纵类中使用最频繁的系统调用。

**3、进程通信类系统调用**

- 当采用信息传递方式时，在通信前须先打开一个连接。为此，应由源进程发出一条打开连接的系统调用，而目标进程则应利用接受连接的系统调用表示同意进行通信：然后，在源进程和目标进程之间便可开始通信。可以利用发送信息的系统调用和接收信息的系统调用来交换信息。通信结束后，还须利用关闭连接的系统调用来结束通信。
- 当采用共享存储区方式时，在通信前须先利用建立共享存储区的系统调用来建立一个共享存储区，再利用建立连接的系统调用将该共享存储区连接到进程自身的虚地址空间上，然后便可利用读和写共享存储区的系统调用来实现相互通信。除了上述的3大类系统调用外，常用的系统调用还包括设备管理类系统调用和信息维护类系统调用，前者主要用于实现申请设备、释放设备、设备I/O重定向、获得和设置设备属性等功能，后者主要用于获得包括有关系统和文件的时间信息、OS版本、当前用户以及有关空闲内存和磁盘空间大小等多方面的信息。

## 1.8 小结

一个完整的计算机系统由硬件和软件组成。硬件是软件得以建立和开展活动的基础，而软件则是对硬件功能的扩充。OS是裸机之上的第一层系统软件，它向下管理系统中各类资源，向上为用户和程序提供服务。本章主要介绍了OS的目标、作用、发展过程、基本特征、运行环境、主要功能、结构以及系统调用等内容。

OS的发展过程很长，从OS开始替代操作人员到发展出现代多道程序系统，这一过程中依次发展出了多种类型的OS，具体而言，有早期的批处理系统、分时系统、实时系统，还有现代的微机OS、嵌人式OS、网络OS和分布式OS等。

OS具有并发、共享、虚拟和异步等特征，其运行需要硬件支持。为了保护系统不被破坏，处理机的运行模式可分为两种，即用户态和内核态，可能引起系统危险的特权指令只能运行在内核态中。OS是中断驱动的，因此中断和异常是计算机系统中的一个重要机制，它保证了OS的正常运行。

传统OS具备的功能包括：进程管理、内存管理、设备管理、文件管理和接口管理。现代OS除了具备传统OS所具备的功能外，还具备保障系统安全、支持用户通过联网获取服务、可处理多媒体信息等功能OS是一个大型的系统软件，采用结构化的设计很重要。早期的OS基本无结构，现代流行的OS则多采用模块化结构、分层式结构、微内核结构等设计而成，最新的OS有的还是采用外核结构设计而成的。系统调用是OS内核与用户程序之间的接口，每个OS都提供了大量的系统调用给程序员使用。

## 2.1 前驱图和程序执行

