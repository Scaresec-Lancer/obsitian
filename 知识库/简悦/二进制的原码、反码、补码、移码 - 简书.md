---
url: https://www.jianshu.com/p/2aa4be79677e
title: 二进制的原码、反码、补码、移码 - 简书
date: 2022-09-19 11:30:32
tag: 
summary: 之前了解一些原码、反码、补码，但是一直有疑问，为什么会有原码、反码、补码？所以决定研究一下。 计算机中参与运算的数有两大类：无符号数和有符号数。此篇主要看一下有符号数。在了解...
---
之前了解一些原码、反码、补码，但是一直有疑问，为什么会有原码、反码、补码？所以决定研究一下。

计算机中参与运算的数有两大类：无符号数和有符号数。此篇主要看一下有符号数。在了解原码、反码、补码前需要先了解机器数和真值。

### 一、机器数

对于有符号数而言，使用 “0” 表示正，“1”表示负，这种把符号 “数字化” 的数称为**机器数**，也就是一个数在计算机中的二进制表示。

例如：+1100 在机器中表示为 0 1100；-1100 在机器中表示为 1 1100

整数的符号位和值用逗号隔开，小数的小数点用点来隔开。  
例如：+3 转换成二进制就是 00000011，-3 就是 10000011，这就是机器数。

### 二、真值

带符号位的机器数对应的真正数值就是**真值**。例如：1000 0011 的真值是 - 3，而不是 131，它的最高位是符号位。

下面开始说原码、反码、补码。

计算机里存储的实际都是数的补码，显示的时候转换为源码。原码和反码都有一定的缺陷。原码虽然表示简单明了，并易于和真值转换，但是在加减法运算时会有很多麻烦，运算步骤复杂费时，还需要计算机提供减法器来支持。而补码却能够满足这些要求，计算机只需要加法器就可以。

### 三、原码

原码是机器数中最简单的一种表示形式，包括符号位和数值位。

**原码：**符号位加上真值的绝对值，即第一位表示符号位，其余为表示值。原码是人脑最容易理解和计算的表示方式。

```
[+1]原 = 0000 0001
[-1]原 = 1000 0001
```

**整数原码的定义：**  

![](http://upload-images.jianshu.io/upload_images/4174612-18b08932a2ac3ca6.jpg)

式中，x 为真值，n 为整数的位数（

**位数不包括符号位，下同**

）。

例如：

当 x=1110 时，[x]

原 =

0,1110；

当 x=-1110 时，[x]

原

=2

4

-(-1110)=1 1110，2 的 4 次方就相当于是符号位。

```
计算过程解释：
对于x的取值范围（例中的4位二进制来说）：
2^n的值为：2^4=16
最大值为：1111 = 1*2^3 + 1*2^2 + 1*2^1 + 1*2^0 =8+4+2+1=15
最小值为：0000=0

当x为负数时，计算过程如下：
[x]原=2^4 - (-1110) = 2^4 + 1110 = 1 0000 + 1110 = 1 1110
```

**小数原码的定义为：**  

![](http://upload-images.jianshu.io/upload_images/4174612-00cbc93089d6b526.jpg)

式中，x 为真值。

例如:

当 x=0.1101 时，[x]

原

=0.1101;

当 x=-0.1101 时，[x]

原

=1-(-0.1101)=1.1101;

**原码的问题：**  
以正负 1 来说明问题，先来看 1+(-1) 的计算过程：

```
1 + (-1)=[0000 0001]原+[1000 0001]原=[1000 0010]原=-2
```

1+(-1)=0，但是用原码来算结果却是 - 2，原码的加法没有问题，但是减法却出现了问题。

### 四、补码

为了解决原码做减法时出现的问题，出现了反码，我们用其他的方式来表示负数，使减法的问题用加法去解决。

**补数的思想：**  
要了解补码的思想就要知道 “模”、“同余”、“补数” 的概念。

在日常生活中，常会遇到 “补数” 的概念。计算机组成原理 (唐朔飞) 中举了一个时钟的例子，现在是 6 点钟，要到达 3 点钟的话该怎么办呢？我们可以顺时针方向将时针移动 9 小时，或是逆时针移动 3 小时，我们都可以到达 3 点钟，假设顺时针转为正，逆时针转为负，则有：

6 - 3 = 6 + 9，3 和 15 都代表 3 点钟

钟表时针转一圈能代表 12 个小时，在数学上称 12 为模，写作 mod 12，对于 mod 12 而言，+9 和 - 3 互为补数，3 和 15 是同余关系，记作 3≡15 (mod 12)，3 + 12 = 15.

其实就相当于没到 12 点就丢失，从 0 点重新开始。

对于时钟运算，减去一个数，是可以等同于加上另外一个正数，例如：6 - 3 = 6 - 3 + 12 = 6 + 9  
其实相当于 6-3 加上模，即相当于是时钟多走了一圈，所以 3 和 15 是等价的。

将补数的概念用到计算机中，便出现了补码这种机器数。

**补码**: 正数的反码是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 + 1. (即在反码的基础上 + 1)，这里只是便于计算才这样说。

对于补码，相当于是模加上真值，就如同上面的 6+(-3)，-3 就是真值。  
**整数补码的定义为：**  

![](http://upload-images.jianshu.io/upload_images/4174612-36213a064802119c.jpg)

式中，x 为真值，n 为整数的位数（对于 8 位二进制数，那么这里的 n 就为 7，第一位是符号位）。

**整数补码定义中 mod 2n+1 的由来：**  
以 8 位二进制为例，整数的位数是 n=7,8 位二进制可以表示的最小值是：0000 0000，最大值是：1111 1111，从 0 到 255，即可以表示 28=256 个数字，所以整数补码的模是 2n+1，即 mod 2n+1。

**原码中的 - 0 在补码中是什么？**  
对于 - 0，根据补码的定义,[-0] 补 =100000-10000=10000, 其实在补码中 - 0 是不存在的，这也是补码出现的原因之一，这里的 10000 只是一种表示方式，所以补码比原码能多表示一个数，这个数就是 - 2n。

例如：  
当 x=+1010 时，[x] 补 =0,1010;  
当 x=-1101 时，[x] 补 =2n+1 + x = 25 - 1101 = 100000 - 1101 = 1,0011

**负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 + 1，计算方式的由来：**  
分析：假如 x=-1011，[x] 补 =25-1011，我们把 25 改写成 100000=11111+00001，可以得到：  
**[x] 补 = 25 + x = 11111 + x + 00001**  
因为 x 是负数，我们可以用 - x1x2x3x4 来表示，单项的 xi 不是 0 就是 1，上面式子可以改写为：  
**[x] 补 = 25 + x = 11111 - x1x2x3x4 + 00001**  
因为 1 减去 1 得 0，减去 0 得 1，负数 - x1x2x3x4 的原码为 1,x1x2x3x4，所以式子中 11111 - x1x2x3x4 就相当于是对原码的取反操作，最后再 + 00001，所以得到上面负数求补码的计算方式。

**小数补码的定义为：**  

![](http://upload-images.jianshu.io/upload_images/4174612-05345237aa68aa67.jpg)

式中，x 为真值，n 为小数的位数。

小数补码定义中 mod 2 的由来：

小数的最大值为：1.1111，当增加 1 时 (1.1111+1)，得到小数补码的模是 2，所以小数补码是：mod 2。

例如：  
当 x=+0.0110 时，[x] 补 =0.1001;  
当 x=-0.0110 时，[x] 补 =2 + x = 10.0000 - 0.0110 = 1.1010  
当 x=0 时，  
[+0.0000] 补 =0.0000;  
[-0.0000] 补 =2 + (-0.0000) = 10.0000 - 0.0000 = 0.0000;  
显然 [+0] 补 =[-0] 补 =0.0000，即补码中的 “零” 只有一种表示形式。

**补码的符号位扩展：**  
1、补码的正负小数符号位扩展就是在末尾加 0 即可，例如：1.1101 扩展为 1.1101 0000  
2、补码的正数符号位扩展在最高位前面加 0 即可，例如：0101 扩展为 0000 0101  
3、补码的负数符号位扩展在最高位前面加 1 既可以，例如：1010 扩展为 1111 1010

### 五、反码

反码通常用来作为由原码求补码或者由补码求原码的中间过渡。  
**反码：**正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。_这个方法只是利于计算，但是并不代表反码的真正含义，可以把它忘记_

```
[+1] = [00000001]原 = [00000001]反
[-1] = [10000001]原 = [11111110]反
```

**整数反码的定义为：**  

![](http://upload-images.jianshu.io/upload_images/4174612-b52ef822b4bac378.jpg)

式中，x 为真值，n 为整数的位数。

例如：

当 x=+1101 时，[x]

反

=0,1101（用逗号将符号位和数值部分隔开）

当 x=-1101 时，[x]

反

=(x

4+1

- 1)+x=1,1111-1101=1,0010

**小数反码的定义为：**  

![](http://upload-images.jianshu.io/upload_images/4174612-4202b6e5f4d7b84a.jpg)

式中，x 为真值，n 为小数的位数。

例如：

当 x=+0.0110 时，[x]

反

=0.0110；

当 x=-0.0110 时，[x]

反

=(2-2

-4

)+x=1.1111-0.0110=1.1001;

当 = 0 时，

[+0.0000]

反

=0.0000；

[-0.0000]

反

=(10.0000-0.0001)-0.0000=1.1111;

由上可见 [+0]

反

和 [-0]

反

是有两种表现方式。

**反码的问题：**  
反码中 0 有两种表示方式，0000 0000 和 1111 1111，这导致在实际计算中每当跨过 0 一次，就有一个单位的误差，所以需要 + 1，即补码的方式。

### 六、移码

因为补码符号位和数值一起编码，所以很难从补码上直接判断出其真值的大小，而用移码就可以很直观的看判断出来。

**移码的定义：**  

![](http://upload-images.jianshu.io/upload_images/4174612-063ada165c7582df.jpg)

式中，x 为真值，n 为整数的位数。

例如：

当 x=10100 时，[x]

移

=2

5

+10100=1,10100

当 x=-10100 时，[x]

移

=2

5

-10100=0,01100

可以直接看出 10100>-10100

利用移码的这一特点，当浮点数的阶码用移码表示时，就能很方便的判断阶码的大小。

**移码**相当于补码的符号位取反。

**_对于补码来说是存在符号位的，使用移码就相当于把补码的负数部分往上移动，使得最小值变为 0，而不是负数。_**

移码更详细的用处以后再研究。

**写在最后：**

*   _如果文章中有错误或是表达不准确的地方，欢迎大家评论中指正，以便我完善。_
*   _文章我也会根据所学到新的知识不断更新。_